{
  "title": "Chapter 1 - Introduction to Software",
  "cells": [
    {
      "type": "markdown",
      "data": "#### What is software?\n+ Instructions that provide an expected function and behaviour when executed\n+ Data structures that allow programs to adequately manipulate info\n+ Documents that describe the operations and use of programs\n\n#### Characteristis:\n+ It is developed -> ***not*** manufactured\n+ It doesn't break down -> it ***deteriorates*** as a result of changes\n+ Most of it tailored for specific purposes -> instead of being assembled from existing components\n\n---\n\n#### Software Crisis -> Basically: Low quality software\n+ Costs are higher than planned\n+ Delivery dates delays\n+ Bad performance\n+ Impossible maintenance\n+ High cost of Updates \n+ Unreliable products\n\n### Quality factors\n#### 1. Operational features\n+ **Correctness:** Does it do what I want?\n+ **Reliability:** Is it reliable all the time?\n+ **Efficiency:** Will it run in the HW platform efficiently?\n+ **Integrity:** Is it safe?\n+ **Usability:** Is it designed to be used?\n\n#### 2. Capability to support updates\n+ **Maintainability:** May it be corrected?\n+ **Flexibility:** May it be easily changed?\n+ **Testability:** May it be verified?\n\n#### 3. Adaptability to new environments\n+ **Reusability:** Is the software reusable?\n+ **Portability:** May it be used in another HW or OS?\n+ **Interoperability:** May it interact with another system?\n\n<br><br>\n\n--- \n\n### Software Industry \n####Â Problems:\n+ Products are low quality\n+ High maintenance and development costs\n+ Delivery delays\n\n#### Causes:\n+ Little investment and effort in the analysis and specification phases\n+ Use of informal and inadequate model\n+ Non physical nature of programming\n+ Poor theoretical foundations\n+ Products already in the market -> difficult innovation\n+ High levels of hand-crafting\n+ Groupwork\n+ Poor communication with users\n+ Project management by non computing engineers\n\n#### Solutions:\n+ **Education:**\n    + Formal methods (formal languages, logic and algebra)\n    + New development of methods and new lifecycles\n+ **Difusion of technological advancements:**\n    + New programming paradigms\n    + New architectures, protocols, computation models\n+ **Tools investment:**\n    + Modern development environments\n    + Documentation generation engines\n\n---\n\n> Software Engineering Process starts well before writing lines of code and it continues after the first version of the product has been completed\n\n### The Software Process\n![Captura de pantalla 2017-11-11 a las 20.15.40.png](quiver-image-url/B106579B5E8766417DD74AC50F501E0A.png =555x248)\n\n<br><br>\n\n#### Management:\n> Is the first level of software development process and covers all the development process\n\n+ Activities involved:\n    + Writing proposal\n    + Project planning\n    + Cost estimation\n    + Selection and evaluation of human resources\n    + Project control\n    + Writing and presenting reports\n\nProject Plan example:\n  1. Intro (goals, restrictions)\n  2. Project organization (team organization)\n  3. Risk analysis (risks, probabilities, strategies)\n  4. Software and Hardware requirements (Adquisistions, prices, delivery dates)\n  5. Division of labour (Activites, milestones, products to deliver)\n  6. Planning (Dependencies between activities, estimated time, assigning resources)\n  7. Supervision and reporting"
    }
  ]
}