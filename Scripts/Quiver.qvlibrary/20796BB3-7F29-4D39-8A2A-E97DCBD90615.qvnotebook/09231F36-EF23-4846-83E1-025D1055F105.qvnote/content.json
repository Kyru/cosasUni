{
  "title": "Chapter 3 - Software Architectures",
  "cells": [
    {
      "type": "markdown",
      "data": "### Intro\n\n> When systems grow in size it is required an organization in terms of subsystems so that they are manageable\n\n#### Structured Methods\n\nA **system** is partitioned in modules that invoque or provide service to other modules.\n\n**Module:**\n+ Part of a program that implements part of the functionality\n+ A module may be decomposed in terms of other modules of a lower level\n\n**Modular Architecture:**\n+ Preliminary Design: Structuring the system in terms of modules (building structure diagram)\n    + Module = Black box\n+ Detailed design: description of process that are implemented by modules\n    + Module = White box\n \n**Problems:**\n+ Approches based on modules and objects are low level ones\n+ They do not divide the application in terms of functional blocks, they are mere grouping of code\n+ A more abstract mechanism is necessary to clearly detect the aspects that are present in most software systems\n\n---\n\n### Software Architectures\n\n> The ***software architecture*** has to do with the design and implementation of high level structures. It is the outcome after assembling a number of different architectural elements in order to adequately satisfy both functional and non functional requirements such as trustability, scalability, portability and availability\n\n#### Client Server\n\n![Captura de pantalla 2017-11-12 a las 19.30.57.png](quiver-image-url/3FCB3DCF455F2360115760DF689A7B81.png =606x315)\n\n#### Multi-Layered Architecture\nA **layered system** is a sorted set of subsystems each one defined in terms of the ones located *below* them and providing the implementation base of the systems above\n\n+ Objects in each layer should be independent, but there can be dependecies between layers\n+ Relation client/server between lower layers (providing services) and upper layers (using those services)\n\nLayered architectures may be open or closed depending on the dependencies:\n+ Open: A layer may use characteristics of any layer\n+ Closed: A layer may only use characteristics of its adjacent lower layer\n\n> Recommended to use close due to the facility of applying changes. As each change only affects the immediate upper layer\n\n#### 2-Layer Architecture - Thin Clients\n\n![Captura de pantalla 2017-11-12 a las 19.41.23.png](quiver-image-url/E45AC7115270C64D50B683AD0D8E9E7B.png =591x359)\n\n> Thin clients can also be multiple computers accessing the same business logic + data\n\n![Captura de pantalla 2017-11-12 a las 19.41.43.png](quiver-image-url/5BFCEAED8FBF9CF8113A2A68975FD980.png =606x428)\n\n#### 2-Layer Architecture - Fat Clients\n![Captura de pantalla 2017-11-12 a las 19.42.56.png](quiver-image-url/FC47F0297E5C6F28FA31F64C6E8C6693.png =576x348)\n\n#### 3-Layer Architecture\n![Captura de pantalla 2017-11-12 a las 19.43.38.png](quiver-image-url/86C01B431D524107C8EFE0AC6032FCF1.png =520x314)\n![Captura de pantalla 2017-11-12 a las 19.49.40.png](quiver-image-url/D5CED87731728D9428F51C9D1147DB40.png =599x399)\n![Captura de pantalla 2017-11-12 a las 19.44.02.png](quiver-image-url/90D54E0D39A3B3EE25BA69FB5E8386BF.png =585x416)\n\nAdvantages:\n+ Business logic isolated from presentation and persistence in a separate component\n+ Distribution of layers in different machines or processes\n+ Possible parallel development\n+ Assigning resources to each layer\n+ Software Reuse!\n\n![Captura de pantalla 2017-11-12 a las 19.46.52.png](quiver-image-url/5C2C97BA37EAE2E15AC7F7A194C5D67F.png =574x428)\n![Captura de pantalla 2017-11-12 a las 19.46.55.png](quiver-image-url/D56932C328F553E255F141217DAB2C6D.png =583x442)\n\n#### Summary\n\n![Captura de pantalla 2017-11-12 a las 19.46.30.png](quiver-image-url/A25CA7D41C36A7F63288E5289AB2C17F.png =601x423)"
    }
  ]
}