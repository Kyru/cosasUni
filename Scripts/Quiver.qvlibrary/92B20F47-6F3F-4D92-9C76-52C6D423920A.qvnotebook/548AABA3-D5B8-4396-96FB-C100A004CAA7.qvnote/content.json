{
  "title": "Unit 1.3 - Instruction set architecture design",
  "cells": [
    {
      "type": "markdown",
      "data": "## 1. General aspects related to instruction sets\n\n**Design factors:**\n+ Instruction sets act as interfaces between programs and datapaths of processors\n+ Instruction results from program compilation\n+ Although programs can be very complex, most of them are very simple\n+ Fast execution of simple instructions possible using simple datapaths\n\n**Main features:**\n+ Basic principle\n    + \"Common case: efficient, Uncommon case: corret\"\n+ Ortogonality\n    + *Whenever it makes sense,* operations, addressing mode and data types must be independent. (simplify generation of code when it involves different compilation phases)\n+ Provision of primitives instead of solutions\n    + Avoid the inclusion of solutions directly supporting high-level instructions\n        + Due to specificity, such solutions only work for particular programming languages\n        + They provide more or less functionality than necessary\n    + Instead, instruction sets must provide to compilers primitives rather tahn to solutions for the generation of optimize code\n+ Principle \"One for all\":\n    + Either there is only one way to make something, or all ways are possible\n        + Reduce the cost of computing each alternative\n  + Integrate instructions operating on constraints (for those values already known at compile-time)\n      + Computation of such values at runtime is not efficient "
    },
    {
      "type": "markdown",
      "data": "## 2. Types of instruction sets\n#### Basic paradigms\n\nClassic criteria: \n+ Storage operants in the CPU\n+ Instructions compute on input data and produce a result\n+ Input data and results can be stored in memory and *CPU*\n\n*Three paradigms:*\n+ **Stack:** Input data and results are stored in the stack. Operands are stored in the stack head and replaced by the result\n+ **Accumulator:** There is an accumulator register storing one of the operands and the final result\n+ **General purpose registers:* Operands and results are in a register file. All operands must be explicitly referenced\n\n![Captura de pantalla 2017-10-28 a las 10.59.50.png](quiver-image-url/EF9C2E32E0200373650EE8EE3B536D00.png =564x354)\n\n![Captura de pantalla 2017-10-28 a las 11.01.52.png](quiver-image-url/49CAAF3CCA5887F772611CFC7634B41C.png =590x164)\n\n> Current instruction sets use a general purpose register file, other paradigms (Stack, accumulator) have disappeared\n\n#### Computers using general purpose registers: a taxonomy\n\n![Captura de pantalla 2017-10-28 a las 11.05.01.png](quiver-image-url/76108C6BA34B90D51AA8D7982CD723D8.png =590x337)\n\n> reg-reg = only registers, reg-mem = both, mem-mem = just memory\n\nTwo main types of instruction sets:\n+ IA Intel Architecture (compatible with AMD processors)\n+ RISC used in MIPS, ARM...\n\n![Captura de pantalla 2017-10-28 a las 11.07.43.png](quiver-image-url/87E4C307B142A6B7AD6F053829E07EB8.png =514x114)\n\n#### L/S and R-M models\n+ RISC L/S Model:\n    + ALU instructions compute only on registers\n    + ALU instructions include three operands\n    + *Load* and *Store* instructions exchange data between registers and memory\n    + The ammount of work performced by all instructions is similar (a computation or memory access)\n+ IA R-M model:\n    + Instructions work on registers, or with an operand in memory\n    + Instructions have two operands\n    + The MOV instruction exchange data R - M and R - R\n    + The amount of work performed by instructions is quite diverse\n\n\n> Remember: Tex = I x CPI x T\n\n+ RISC L/S Model:\n    + A program has more instructions to carry out the same work. **I increases**\n    + Simple format, easier decoding. **T decreases**\n    + The amount of work per instruction remains similar. **CPI decreases**\n+ IA R-M Model:\n    + A program integrates less instructions to perform the same work. **I increases**\n    + Variable format, more comple decoding. **T increases**\n    + Heterogeneous amount per instructions. **CPI increases**\n\n![Captura de pantalla 2017-10-28 a las 11.15.43.png](quiver-image-url/9DB0907E4EFDD577A11FC2C03765FCD6.png =478x185)"
    },
    {
      "type": "markdown",
      "data": "## 3. Registers and Operand types\n\n+ RISC: \n    + Big number of registers, all of them with the same length (32 registers)\n    + Regular instructions use the whole content of registers\n    + L/S instructions transform integer types whenever necessary\n+ IA:\n    + Few registers that are adapted to the available data types\n    + Each ALU instruction has a different operation code for each data type\n    + In x86-64 there are 4 versions of add for operands of 8, 16, 32 and 64 bits\n\n*Example: IA-32 registers*\n\n![Captura de pantalla 2017-10-28 a las 11.21.28.png](quiver-image-url/363F3616A2BADB1F95B1694B899C68EE.png =271x227)\n\nHere we have 8 registers of 32 bits EAX ... EDI. We can manage the low part as 4 registers of 16 bits or 8 registers of 8 bits\n\n*Example: MIPS registers*\n\n![Captura de pantalla 2017-10-28 a las 11.23.27.png](quiver-image-url/4337617E6A63D915936BA3351B6CD68B.png =403x254)\n\n32 registers of 32 bits: R0 ... R31. Specific registers have specific operations. This is the typical agreement used by compilers.\n\n![Captura de pantalla 2017-10-28 a las 11.23.52.png](quiver-image-url/9BCB97706B9948064337DBAF69D70AC4.png =588x204)"
    },
    {
      "type": "markdown",
      "data": "## 4. Instruction encoding\n#### Encoding strategies\n\n**Fixed vs Varible Format:**\n+ Fixed: All instructions are encoded using the same number of bits\n    +  It easies fetching and decoding of instructions\n    +  Sometimes, it wastes bits in the format, since all instructions do not require the same amount of bits to be encoded\n+  Variable: The require number of bits for encoding varies attending to the instruction type\n    + Space taken by instructions (and programs) is optimized\n    + It makes more complex fetching and decoding of instructions\n\n**Number of bits of the format:** limits the sapce devoted to each instruction field, which limits the number of available variants\n+ Number of instructions (Operation codes)\n+ Number of registers\n+ Addressable memory space\n+ etc.\n\n**Number of instruction formats:**\n+ One format: The correspondence between format bits and fields is always the same\n    + Easies instruction decoding\n    + Sometimes, format bits are wasted, since not all instructions require all the available fields\n+ Multiple formats: Each format can have a different fields and establishes a correspondence between such fields and the format bits\n    + Allow a better adjustment of those bits taken by each instruction and the required fields "
    },
    {
      "type": "markdown",
      "data": "## 5. Memory Addresing\n\n+ Physical reading/writing units (words) contain W = 2<sup>w</supp> addressable units (bytes)\n+ Words referred through the address of their least significant byte:\n+ Two alternatives:\n    + IA Little Endian: Byte with address A is located at the least significat position\n    + RISC Bib Endian: Byte with address A is located at the most significant word position\n\n![Captura de pantalla 2017-10-28 a las 12.02.12.png](quiver-image-url/AE0E2B82423496D73EFC638755EBE37D.png =246x186)\n\n> First: little endian, Second: Big endian\n\n**Alignment:**\n+ RISC Aligned access:\n    + The address of the object 2<sup>i</sup> bytes is a multiple of 2<sup>i</sup>\n    + For example in MIPS-32: the address of a halfword is always even, and the address of a word is a multiple of 4\n+ IA Non-aligned access:\n    + There is no restriction\n    + An instruction can access contiguous byte in two consecutive words, and its execution will demand two physical accesses to memory\n        + Impact -> higher CPI and T\n\n**Adressing modes:**\nUsed to specify instruction operands. If sophisticated:\n+ Reduces the number of program instructions -> lower I \n+ More complex hardware -> Increases CPI and T\n\n![Captura de pantalla 2017-10-28 a las 12.10.42.png](quiver-image-url/19E1ACCF90417B3E43195F432E6F6D23.png =593x337)\n\nIA x86-64 includes even the scaled mode:\n\n![Captura de pantalla 2017-10-28 a las 12.13.27.png](quiver-image-url/E3D09BB945DDA1B8A5C4D3799E06F543.png =593x188)\n\n> Which means it can combine several instructions into just one instruction. However, with this an instruction may have a lo of work.\n\nRISC: two versions of ALU instructions available\n+ R-format: Rd <- Rs op Rt (ADD)\n+ I-format: Rd <- Rs op X (ADDI)\n\nMain memory accesses must be performed using the displacement addressing mode: X(Rn)\n+ Using X = 0 results in the register indirect addressing mode\n+ Using Rn = $zero reslts in the absolute mode\n\nDisplacement range: solution that must balance the size of the necessary displacements and the number of required bits. (16 bits in MIPS)"
    },
    {
      "type": "markdown",
      "data": "## 6. Operands and operations\n\nMost commonly supported types:\n+ char\n+ integer (2s complement)\n+ Floating point (single precision 32, double precision 64)\n\n**A variety of operations:**\n+ Integer arithmetic, binary logic\n+ Transfer: *Load/store* or *move*\n+ Control: branches and jumps, call/return\n+ System: OS calls, virtual memory management\n+ Floating point: arithmetic and decimal-char conversions\n+ Strings: transference, comparison, search\n+ Multimedia: *vertex* and *pixels* operations, comp/decompression, SIMD instructions"
    },
    {
      "type": "markdown",
      "data": "## 7. Control flow\n#### Control instructions\nTypes:\n+ Conditional branches (branch)\n+ Unconditional branches (jump)\n+ Call/return to/from a procedure\n\nPC-relative (program counter):\n+ Destination used must be near the current instruction\n+ Number of bits encoding the displacement: 16-20 (conditional) and 26 (unconditional)\n\nIndirect link: useful is branch destination is unknown at compilation time\n+ Statements selecting ove over several alternatives (case, switch)\n+ Virtual methods in oo-languages\n+ Exchange of functions as parameters for other functions\n+ Dynamically linked libraries\n\n*Jump and link:* (jal)\n+ Used to invoke subprograms\n+ It is a branch using a Relative-PC or indirect link adressing mode and storing the return address in a register\n+ The subprogram *return* is performed using an indirect link addressing mode. The address (link) stored by the jump instruction in the corresponding register is now used to return\n\n#### Branch conditions\nHow to speciy them? Several alternatives:\n1. Condition codes (IA):\n    + The instruction set defines an \"state\" that is modified according to the state of the last ALU operation\n    + Tipically there are some condition codes or *flags*: C(carry), Z(zero), N(negative), etc.\n    + Branch conditions simply check condition codes\n    + **Drawbacks:**\n        + Generation of condition codes is not trivial and requires space inside the chip\n        + The modification of condition codes by all instructions poses some problems for code reordering and for multiple issuing of ALU instructions\n2. Explicit check (MIPS): result operations is explicitly checked using specific instructions. For example: `bnez r10, dest` (branch not equal zero)\n\n\n#### Conditional instructions\n\nAdding an additional operand (the condition) to conventional instructions\n+ If TRUE execute normally\n+ If FALSE, the instruction behaves as a NOP\n\n**Useful** Because it reduces branch instructions -> and so reduces I \n\n![Captura de pantalla 2017-10-28 a las 12.43.22.png](quiver-image-url/C0C413E7BC79BD94C2CD4B818B03FFC7.png =583x380)\n\n**Limitations of conditional instructions:**\n+ They spend clock cycles and so if an exessive use of conditional instructions may en up increasing I\n    + Example: If a branch is implemented with conditional instructions, both instructions paths must be executed, while in the conventional code only one instruction path is executed\n+ If the control flow leads to the execution of nested conditional sentences, the use of conditional instructions become less effective\n    + Example: Moving an instruction accross two branches -> either the instruction includes both conditions, or additional instructions will be required in order to combine the conditions\n+ CPI may be increased or clock frequency may be reduced"
    },
    {
      "type": "markdown",
      "data": "## 8. MIPS instruction set\n![Captura de pantalla 2017-10-28 a las 12.48.51.png](quiver-image-url/1FCFC2F2B8755A5C15F4FA94C0CB3A61.png =564x341)![Captura de pantalla 2017-10-28 a las 12.48.57.png](quiver-image-url/C5FA72FB2DC69B785D78B9A3F47D5CF9.png =571x334)"
    },
    {
      "type": "markdown",
      "data": "## SIMD Instructions\n#### Vector processors\n\nMany numerical applications require processing large arrays of data and so instructions that operated on vectors where developed.\n+ A vector instruction operates with vectors of a given maximum size (64 or 256), formed by elements of a certain size (32 or 64)\n+ The types of data they handle are, almost always, FP in single or double precision\n\n#### Packed data types\n\nSIMD (single-instruction - multiple-data) instructions operate on registers that contain several packed data\n+ They support different data types: 8, 16, 32, 64 integers and single/double precission floating point\n+ The number of data contained in a register is \n    + $n = \\frac{register-size}{size-of-data-type}$ \n+ The registers have a fixed size, but the instruction set allows packing data of different sizes \n    + For example: 8 data of type byte, 4 data of type halfword, etc.\n\n\n![Captura de pantalla 2017-10-28 a las 13.04.33.png](quiver-image-url/CD09102E77F7AA5E04A4EB7BF0D18DBC.png =571x277)\n\n**Evolution of SIMD instructions on Intel processors**\n***Trend:*** A significant percentage of the additional transistors in each new generation of processors is devoted to increasingly powerful vector instructions and larger vector register files\n\n#### Example SAXPY\n\n![Captura de pantalla 2017-10-28 a las 13.09.05.png](quiver-image-url/8016F150E629F2A203B6AC2B5501C676.png =591x358)\n![Captura de pantalla 2017-10-28 a las 13.09.09.png](quiver-image-url/4EAE68976E17ED72C44547563C3D0AD5.png =582x359)\n![Captura de pantalla 2017-10-28 a las 13.09.14.png](quiver-image-url/225B8CFAAEC7390DD81501452067FBA5.png =584x370)\n![Captura de pantalla 2017-10-28 a las 13.09.19.png](quiver-image-url/70AF3C71974A2B4BB7F10EC180974309.png =584x367)\n![Captura de pantalla 2017-10-28 a las 13.09.24.png](quiver-image-url/9222A865079CEA11B9F37B0E7FFB78AE.png =589x351)\n\n#### Compiler support\n\nCompilation is based on data types and expressions to generate code.\n+ If the programmer writes the code in a scalar manner, a classical compiler will not use SIMD instructions\n\nThree ways to insert SIMD instructions into the code:\n+ Automaitc vectorization:\n    + The programmer does not explicitly describe the parallelism. An advanced compiler extracts parallelism from scalar source code\n+ Using SIMD data types:\n    + The programmer defines the relevant variables with a specific data type and uses them in common language expressions\n+ *Instrinsic* functions:\n    +  The language has a library of SIMD functions\n    +  The programmer uses them explicitly\n\n#### Compilation Example:\n\n![Captura de pantalla 2017-10-28 a las 13.15.46.png](quiver-image-url/2B98388BAA033FF8374AC16CEE02FBBF.png =580x320)\n![Captura de pantalla 2017-10-28 a las 13.15.52.png](quiver-image-url/3D23310F31DAE712D1C7D09B87DD0B27.png =573x333)\n![Captura de pantalla 2017-10-28 a las 13.15.56.png](quiver-image-url/ACF2D2873D5B6E207B8052124A29A3EF.png =578x337)\n\n#### Example Vector dot product\n\n![Captura de pantalla 2017-10-28 a las 13.17.58.png](quiver-image-url/DB4FF5393D6ED0E3B47C9E3AF23ABB3B.png =591x342)\n![Captura de pantalla 2017-10-28 a las 13.18.16.png](quiver-image-url/0B67C79510932F99769A5EA4EC2650F2.png =591x340)\n![Captura de pantalla 2017-10-28 a las 13.18.21.png](quiver-image-url/565FBA7BB78C2C1256CD46D6D72AD287.png =594x326)\n![Captura de pantalla 2017-10-28 a las 13.18.31.png](quiver-image-url/C8E9CE796B26F8263D144DA3130CC24C.png =591x279)\n![Captura de pantalla 2017-10-28 a las 13.18.36.png](quiver-image-url/A216B4BF7B85DDADABE9E3E81E215F52.png =548x344)\n"
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": ""
    }
  ]
}